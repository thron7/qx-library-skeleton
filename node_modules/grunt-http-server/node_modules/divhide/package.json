{
  "name": "divhide",
  "description": "Divhide javascript core components for NodeJs, Browser, Titanium, ... and everything that runs javascript.",
  "version": "2.0.1",
  "author": {
    "name": "Oscar Brito",
    "email": "aetheon@gmail.com",
    "url": "https://twitter.com/aetheon"
  },
  "keywords": [
    "divhide",
    "utils",
    "validation",
    "type",
    "schema",
    "safe",
    "i18n",
    "chain",
    "error",
    "exception",
    "assert"
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git@github.com:divhide/node-divhide.git"
  },
  "devDependencies": {
    "browserify": "9.0.7",
    "browserify-istanbul": "^0.2.1",
    "expect.js": "^0.3.1",
    "grunt": "~0.4.5",
    "grunt-browserify": "=3.8.0",
    "grunt-bump": "0.0.16",
    "grunt-cli": "",
    "grunt-contrib-jasmine": "*",
    "grunt-contrib-jshint": "*",
    "grunt-contrib-watch": "*",
    "grunt-exec": "^0.4.6",
    "grunt-http-server": "*",
    "grunt-karma": "^0.11.1",
    "grunt-karma-coveralls": "^2.5.3",
    "grunt-readme": "0.4.5",
    "grunt-simple-mocha": ">=0.4.0",
    "karma": "^0.12.37",
    "karma-chrome-launcher": "^0.2.0",
    "karma-coverage": "^0.4.2",
    "karma-jasmine": "^0.3.5",
    "karma-phantomjs-launcher": "^0.2.0",
    "karma-threshold-reporter": "^0.1.15",
    "load-grunt-tasks": "3.0.0",
    "phantomjs": "^1.9.17"
  },
  "dependencies": {
    "lodash": "=3.9.3"
  },
  "main": "src/Index.js",
  "engines": {
    "node": ">=0.10.2"
  },
  "scripts": {
    "test": "grunt --verbose"
  },
  "readme": "# [![Divhide](http://blog.divhide.com/assets/images/divhide_128px.png)](http://divhide.com/) divhide-core\n\n[![Build Status](https://travis-ci.org/divhide/node-divhide.png?branch=master)](https://travis-ci.org/divhide/node-divhide) [![Coverage Status](https://coveralls.io/repos/divhide/divhide-core/badge.svg)](https://coveralls.io/r/divhide/divhide-core) [![NPM version](https://badge.fury.io/js/divhide.svg)](http://badge.fury.io/js/divhide) [![Dependency Status](https://gemnasium.com/divhide/divhide-core.svg)](https://gemnasium.com/divhide/divhide-core)\n\n[![NPM Stats](https://nodei.co/npm/divhide.png?downloads=true)](https://www.npmjs.com/package/divhide) ![alt text](https://raw.githubusercontent.com/divhide/divhide-core/master/.readme/assets/bower-logo.jpg) ![alt text](https://raw.githubusercontent.com/divhide/divhide-core/master/.readme/assets/titanium-logo.png)\n\n[![Donate](https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=NYVPSL7GBYD6A&lc=US&item_name=Oscar%20Brito&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted)\n\n\nJavascript codebase to use on the Browser, NodeJS and other javascript platforms. This provides a set of utilities that you can use everywhere.\n\nThe intent of this library is to expose some building blocks that you can use when building a library, a mobile application, a web page, a web server, a command line utility...\n\nPlease note that **all examples are integrated on the CI build** and that's the reason why you'll see `expect` statements.\n\n\n\n### Install\n\n### Node.js\n\n```\n\nnpm install divhide\n\n```\n\n``` js\n\n\nvar Divhide = require(\"divhide\");\n...\n\n\n```\n\n\n### Bower\n\n```bash\n\nbower install divhide\n## or download **divhide.js** from the **dist/** folder.\n\n```\n\n\n\n``` html\n\n\n<script type=\"text/javascript\" src=\"//bower_components/divhide/dist/divhide.js\"></script>\n<script type=\"text/javascript\">\n    var fn = Divhide.Safe.function();\n    ...\n</script>\n\n\n```\n\n### Titanium\n\n```\n\nDownload dist/divhide.js from github and use it as a library.\n\ne.g.\nvar Divhide = require(\"/vendor/divhide\");\n\n```\n\n\n\n\n## API\n\n* [API](#api)\n  * [I18N](#i18n)\n  * [Exception](#exception)\n  * [Assert](#assert)\n  * [Assertion](#assertion)\n  * [Chain](#chain)\n  * [Schema](#schema)\n  * [CustomSchema](#customschema)\n  * [Type](#type)\n  * [Safe](#safe)\n  * [Obj](#obj)\n  * [Arr](#arr)\n* [Contribute](#contribute)\n* [Authors](#authors)\n* [License](#license)\n\n\n### I18N\n\nThe Internationalization package. This package provides you with some utilities that will help you\non your internationalization tasks.\n\nThere's no intention for this library to contain translations for other languages.\n\n#### I18NString\n\nThe I18NString is a String representation that can be translated. This string can be a plain String or\na lodash template.\n\nThis implementation creates a clear separation between the translation mechanism and it's internal logic. This package is used across the library in order to provide I18N out of the box!\n\n**Constructor**\n\n* `new I18N.String(message, data?, translations?)`\n<br />\nCreates a String instance with the given *message*, associated *data*, and an object which contain the *translation*.\n\n**Methods**\n\n* `.toString(translations?)`\n<br />\nGets the string representation of the error. If _translations_ object is provided the message Error message will try to be translated.\n\n**Example**\n\n```js\n\n\nvar I18NString = Divhide.I18N.String;\n\n/// the external translation data\nvar Portuguese = {\n    \"hello <%= username %>\": \"olá <%= username %>\"\n};\n\n/// create a I18NString (message + data)\nvar message = new I18NString(\"hello <%= username %>\", { username: \"oscar\" });\n\n/// Gets the English message\nvar en = message.toString();\nexpect(en)\n    .toBe(\"hello oscar\");\n\n/// Gets the Portuguese message\nvar en = message.toString(Portuguese);\nexpect(en)\n    .toBe(\"olá oscar\");\n\n\n```\n\n\n### Exception\n\nThe Exception package provides some utilities created in order to normalize the Error handling.\n\nAll the Exceptions classes inherit from Error. Also, these classes are using the I18N\npackage.\n\n\n#### Exception\n\nThe Exception class inherits from Error. This class is integrated with I18N package.\n\n**Constructor**\n\n* `new Exception.Exception(message, data?)`\n<br />\nCreates an instance of an exception with the given _message_ and _data_.\n\n**Methods**\n\n* `.message`\n<br />\nGets the string representation of the error.\n\n* `.toString(translations?)`\n<br />\nGets the string representation of the I18NString. You can provide a *translation* object.\n\n**Example**\n\n```js\n\n\nvar Exception = Divhide.Exception.Exception;\n\n/// the external translation data\nvar Portuguese = {\n    \"The maximum value allowed is <%= value %>.\": \"Valor máximo é <%= value %>.\"\n};\n\nvar error = new Exception(\n    \"The maximum value allowed is <%= value %>.\",\n    { value: 10 });\n\n/// Exception instance is an error!\nexpect(error instanceof Error)\n    .equals(true);\n\n/// Exception message\nexpect(error.toString())\n    .equals(\"The maximum value allowed is 10.\");\n\n/// I18N Exception message\nexpect(error.toString(Portuguese))\n    .equals(\"Valor máximo é 10.\");\n\n\n\n```\n\n#### ExceptionList\n\nThis allows you to create an Exception that contains inner exceptions.\n\nThe ExceptionList is also an instance of Error and compatible with the I18N package.\n\n**Constructor**\n\n* `new Exception.ExceptionList()`\n\n**Methods**\n\n* `.message`\n<br />\nGets the string representation of the ExceptionList.\n\n* `.items`\n<br />\nGets the list of inner Error.\n\n* `.length`\n<br />\nGets length of the ExceptionList\n\n* `.clear()`\n<br />\nClear the ExceptionList\n\n* `.push(Error)`\n<br />\nPush an Error instance to the ExceptionList\n\n* `.push(ExceptionList)`\n<br />\nMerge the given ExceptionList into the instance\n\n* `.toString(translations?)`\n<br />\nGets the string representation of the I18NString. You can provide a *translation* object.\n\n\n**Example**\n\n```js\n\n\nvar Exception       = Divhide.Exception.Exception,\n    ExceptionList   = Divhide.Exception.ExceptionList;\n\n\nvar errors = new ExceptionList();\n\n/// is an instance of Error\nexpect(errors instanceof Error)\n    .toEqual(true);\n\n/// adding errors to ExceptionList ( you can also merge other ExceptionList! )\nerrors.push( new Exception(\"Error1\") );\nerrors.push( new Exception(\"Error2\") );\nerrors.push( new Exception(\"Error3\") );\n\n/// get length of the list\nexpect(errors.length)\n    .toEqual(3);\n\n/// get an error from the list\nexpect(errors.items[0].toString())\n    .toEqual(\"Error1\");\n\n/// get the translated error\nexpect(errors.toString({ \"Error1\": \"Error 1\", \"Error2\": \"Error 2\", \"Error3\": \"Error 3\" }))\n    .toEqual(\"Error 1, Error 2, Error 3\");\n\n\n\n\n```\n\n\n### Assert\n\nThe Assert facility provides an assertion expression builder with some pre-built functions.\n\n**Methods**\n\n* `.required()`\n<br />\nSet the expected value to be defined\n\n* `.string()`\n<br />\nSet the expected value to be a string\n\n* `.array()`\n<br />\nSet the expected value to be an array\n\n* `.object()`\n<br />\nSet the expected value to be an object\n\n* `.number()`\n<br />\nSet the expected value to be a number\n\n* `.max(number)`\n<br />\nSet the expected value to have a specified maximum. In the case of String or Array the context will be the value length. In the case of an object will be the number of keys\n\n* `.min(number)`\n<br />\nSet the expected value to have a specified minimum. In the case of String or Array the context will be the value length. In the case of an object will be the number of keys\n\n* `.instanceOf(fn)`\n<br />\nSet the expected value to be an instance of the given function.\n\n* `.regex(value)`\n<br />\nSet the expected value to pass the regex\n\n* `.isValid(value)`\n<br />\nTest if the given value is valid within the current assertion\n\n* `.assert(value)`\n<br />\nReturn the given value if valid; otherwise will throw an Exception\n\n**Example**\n\n```js\n\n\nvar Assert = Divhide.Assert;\n\n/// Test if the value is valid\nvar isValid = Assert.required()\n    .string()\n    .regex(\"^M\")\n    .max(10)\n    .min(5)\n    .isValid(\"Mary\");\n\nexpect(isValid)\n    .toBe(false);\n\n\n/// Valid assertion:\nvar obj = Assert.required()\n    .array()\n    .max(5)\n    .assert([1, 2, 4, 5]);\n\nexpect(obj)\n    .equals([1, 2, 4, 5]);\n\n\n/// Invalid assertion:\nvar fn = function(){\n\n    Assert.required()\n        .array()\n        .max(1) /// will be on array context\n        .assert([\"first\", \"second\"]);\n\n};\n\nexpect(fn)\n    .toThrow();\n\n\n\n\n```\n\n\n\n### Assertion\n\nAssertion facility provides a way to build custom Asserts. You can create your own assertion functions\nand integrate them with the Assert facility.\n\n**Constructor**\n\n* `new Assertion(methods)`\n<br />\nCreates a custom assertion instance that contains the given methods plus the default methods (see Assert).\n\n\n```js\n\n\n/// Assertion builder\nvar Assertion = Divhide.Assertion;\n\n/// Create the custom Assert facility\nvar Assert = new Assertion({\n\n    /**\n     *\n     * Tests if the string starts with the given value\n     *\n     * @param  {String} val\n     * @param  {String} str\n     * @return {String}\n     */\n    startsWith: function(val, str){\n\n        if(val.indexOf(str) !== 0){\n            throw new Error(\"Does not starts with \" + str);\n        }\n\n    }\n\n});\n\n/// Test if the value is valid\nvar isValid = Assert\n                .required()\n                .string()\n                .startsWith(\"Mary\")\n                .isValid(\"Mary and Peter\");\n\nexpect(isValid)\n    .toBe(true)\n\n\n/// Assert value\nvar value = Assert\n            .required()\n            .string()\n            .startsWith(\"Mary\")\n            .assert(\"Mary and Peter\");\n\nexpect(value)\n    .equals(\"Mary and Peter\");\n\n\n\n\n\n```\n\n\n\n\n### Chain\n\n\nChain facility provides an API to create chainable functions. Each Chain is created by a list of chainable functions, a list of evaluation\nfunction and some options.\n\n**Constructor**\n\n* `new Chain(chainableFns, evaluationFns, options)`\n<br />\nCreates a Chain instance that allows you to execute chainable methods (__chainableFns__). The chain is only executed\nwhen an evaluation method (__evaluationFns__) is called.\n<br />\n    * chainableFns\n    * evaluationFns\n    * options - `{ pipe: Boolean, type: Function, argument: *, scope: Object }`.\n\n```js\n\n\nvar Chain = Divhide.Chain;\n\n\nvar Maths = new Chain(\n\n    /// the chaining fns\n    {\n        sum: function(i,j){\n            return i + j;\n        },\n\n        sub: function(i, j){\n            return i - j;\n        }\n    },\n\n    /// the evaluation fns\n    {\n        calculate: function(result, err){\n            return result;\n        }\n    },\n\n    /// the options\n    {\n\n        /// if true the return of a function is passed as an argument to the next one\n        /// if false, the evaluation arguments are passed to every chain function (default)\n        pipe: true\n\n    });\n\n\nvar value = Maths.sum(5)\n    .sub(3)\n    .sum(10)\n    .calculate(0);\n\nexpect(value)\n    .toBe(12);\n\n\n\n```\n\n\n\n\n### Schema\n\nThe Schema facility provide an easy way to write validation rules. Using a chainable API you can\ncompile and/or evaluate the rules.\n\n**Methods**\n\n`.any()`\n<br />\nSet the expected type as any object.\n\n`.strict()`\n<br />\nDisable the type coercion. Strict types are required.\n\n`.string()`\n<br />\nSet the expected type as a string\n\n`.number()`\n<br />\nSet the expected type as a number\n\n`.boolean()`\n<br />\nSet the expected type as a boolean\n\n`.object(value)`\n<br />\nSet the expected type as an object. The **value** is an object with rules.\n\n`.array(value)`\n<br />\nSet the expected type as an object. The **value** is an array with rules.\n\n`.function()`\n<br />\nSet the expected type as a function.\n\n`.required()`\n<br />\nSet as required.\n\n`.optional()`\n<br />\nSet as optional\n\n`.default(value)`\n<br />\nSet the default value. This is used when the schema its required and the provided value is null.\n\n`.repeatable()`\n<br />\nSet the type as repeatable. This repeats the schema through the structure (array only!).\n\n`.min(value)`\n<br />\nSet the min value expected. If in number context the value is used. If in string context the length is used.\nIf in array context the length is used. If in object context the number of keys is used.\n\n`.max(value)`\n<br />\nSet the max value expected. If in number context the value is used. If in string context the length is used.\nIf in array context the length is used. If in object context the number of keys is used.\n\n`.regex(value)`\n<br />\nSets a regexp condition ( only use on string context! )\n\n`.compile()`\n<br />\nCompiles the schema. If you are using the same Schema multiple time you can compile it for performance reasons.\nThis avoid compiling the Schema before every usage.\n\n`.value(value)`\n<br />\nTest the schema returning the normalized value if valid. Throws an Error if invalid.\n\n`.isValid(value)`\n<br />\nTest the schema return if its valid or not.\n\n`.errors(value)`\n<br />\nTest the schema returning an Array with the errors\n\n`.serialize()`\n<br />\nGets the serialized schema representation.\n\n`.deserialize(value)`\n<br />\nGets the Schema from the given value.\n\n\n**Example** overview\n\n```js\n\n\nvar Schema = Divhide.Schema;\n\n\n/// get the schema\nvar schema = Schema.object({\n\n        /// array with multiple strings\n        data: Schema.array([ \"\" ]).repeatable().max(10),\n\n        /// every other object key is optional\n        \"/.*/\": Schema.number().optional()\n\n    }).required();\n\n\n/// apply the schema to the value\nvar value = schema.value({\n    data: [ 1, 2, 3, 4, 5, 6],\n    timestamp: \"1404373579473\"\n});\n\n\n/// test the value\nexpect(value).equals({\n    data: [ '1', '2', '3', '4', '5' , '6'],\n    timestamp: 1404373579473\n});\n\n\n\n```\n\n**Example** String Schema\n\n```js\n\n\nvar Schema = Divhide.Schema;\n\nvar serialized =\n        Schema.object({\n            \"name\"      : \"\",\n            \"friends\"   : Schema.array([\n                {\n                    name: \"\"\n                }\n            ]).optional(),\n        })\n        .required()\n        .serialize();\n\n/// deserialize the object\nvar schema = Schema.deserialize(serialized);\n\n/// let's get the object\nvar value = schema.value({\n    id: 1,\n    name: \"Oscar\",\n    friends: [{ name: \"Solange\" }]\n});\n\nexpect(value).equals({\n    name: \"Oscar\",\n    friends: [{ name: \"Solange\" }]\n});\n\n\n\n\n\n```\n\nTime to see some code! Some usage examples are described below.\n\n**Example** Number Schema\n\n```js\n\n\nvar Schema = Divhide.Schema;\n\nvar schema = Schema.number()\n                .optional()\n                .min(3)\n                .max(5)\n                .compile();\n\n\n/// value is correct\nvar value = schema.value(3);\nexpect(value).toBe(3);\n\n\n/// optional value\nvar value = schema.value();\nexpect(value).equals(null);\n\n\n/// value is undefined\nexpect(\n    function(){\n        schema.value(0);\n    })\n    .toThrow(\n        new Error(\"The minimum value allowed is 3.\")\n    );\n\n\n/// values exceed the max\nexpect(\n    function(){\n        schema.value(10);\n    })\n    .toThrow(\n        new Error(\"The maximum value allowed is 5.\")\n    );\n\n\n/// because is optional, is valid!\nvar isValid = schema.isValid();\nexpect(isValid).toBe(true);\n\n\nisValid = schema.isValid(3);\nexpect(isValid).toBe(true);\n\n\nisValid = schema.isValid(10);\nexpect(isValid).toBe(false);\n\n\n\n\n\n```\n\n**Example** Schema (de)serialization\n\n```js\n\n\nvar Schema = Divhide.Schema;\n\n\n/// String schema\nvar schema = Schema.string()\n                .required()\n                .min(3)\n                .max(5);\n\n\n/// returns the value\nvar value = schema.value(\"hello\");\nexpect(value).toBe(\"hello\");\n\n\n/// value is required!\nexpect(\n    function(){\n        schema.value();\n    })\n    .toThrowError(\"Value is required., The minimum value allowed is 3.\");\n\n\n/// value is required!\nexpect(\n    function(){\n        schema.value(\"hello world\");\n    })\n    .toThrow(new Error(\"The maximum value allowed is 5.\"));\n\n\n/// Check if is valid\nvar isValid = schema.isValid(\"\");\nexpect(isValid).toBe(false);\n\n\nvar isValid = schema.isValid(\"hello\");\nexpect(isValid).toBe(true);\n\n\nvar isValid = schema.isValid(\"hello world\");\nexpect(isValid).toBe(false);\n\n\n\n\n\n```\n\n**Example** Object Schema\n\nObjects schema is set by applying rules to each property of the object. You can also use regular expressions on\nthe schema object keys to give better filtering.\n\nYou can also set the schema object keys to primitive values which will be interpreted as `required().default(value)`\nin the schema.\n\n```js\n\n\nvar Schema = Divhide.Schema;\n\nvar schema =\n        Schema.object({\n            \"/^optional/\"   : Schema.string().optional(),\n            \"number\"        : 0,\n            \"string\"        : \"\",\n        })\n        .required()\n        /// TIP: When compiled the schema is faster\n        .compile();\n\n\n/// let's get the object\nvar value = schema.value({\n    string      : \"awesome!\",\n    number      : \"0\",\n    optional1   : \"1\",\n    optional2   : \"2\",\n    other       : 1\n});\n\n\n/// Please notice that some of the object properties were\n/// not included!\nexpect(value).equals({\n    \"number\": 0,\n    \"string\": \"awesome!\",\n    \"optional1\": \"1\",\n    \"optional2\": \"2\"\n});\n\n\n\n\n\n```\n**Example** Array Schema\n\nThe following example describe an array rule that is optional and its expecting three items.\n\n```js\n\n\nvar Schema = Divhide.Schema;\n\n\n/// Array schema ( no repeatable)\nvar schema = Schema\n    .array([ Schema.string().default(\"value\"), Schema.number(), Schema.string() ])\n    .optional()\n    .compile();\n\n\n/// because its optional it returns null\nvar value = schema.value();\nexpect(value).toBe(null);\n\n\n/// The value is right!\nvalue = schema.value([ '1', 2, '3' ]);\nexpect(value).equals([ '1', 2, '3']);\n\n\n/// array have more items than it should\nexpect(\n    function(){\n        schema.value([ '1', 2, '3', 4, 5, 6 ])\n    })\n    .toThrow(\n        new Error(\"Expected list with 3 items but found 6.\")\n    );\n\n\n/// Wrong type!\nexpect(\n    function(){\n        schema.value(10);\n    })\n    .toThrow(\n        new Error(\"'array' was expected but found 'number' instead.\")\n    );\n\n\n///\n/// Just another way to write the rule!\n///\n\n\nvar schema = Schema\n    .array([ Schema.string(), Schema.number() ])\n    .repeatable()\n    .optional()\n    .compile();\n\n\n// Get the value\nvar value = schema.value([\"1\", 2, \"3\", 4]);\nexpect(value).equals([\"1\", 2, \"3\", 4]);\n\n\n// because the number of item on the array must be multiple of 2\n// an error is thrown\nexpect(\n    function(){\n        schema.value([\"1\", 2, \"3\"])\n    })\n    .toThrow(\n        new Error(\"Expected list length to be multiple of 2 but found length of 3.\")\n    );\n\n\n\n\n\n```\n\n\n\n### CustomSchema\n\n\n### Type\n\nType facility provides an API that can help you with typical operations using the javascript\ndata Types.\n\n**Methods**\n\n* `.of(value)`\n<br />\nGets the string representation of the given value.\n\n* `.isArray(value)`\n\n* `.isBoolean(value)`\n\n* `.isFunction(value)`\n\n* `.isString(value)`\n\n* `.isObject(value)`\n\n* `.isBoolean(value)`\n\n* `.isRegExp(value)`\n\n* `.isRegExpStr(value)`\n\n* `.isNumber(value)`\n\n* `.instanceOf(value)`\n\n* `.isDefined(value)`\n<br />\nChecks if the value is defined.\n\n* `.isEmpty(value)`\n<br />\nChecks if the value is empty (executed in string, list and object context ).\n\n```js\n\n\nvar Type = Divhide.Type;\n\nvar type = Type.of({});\nexpect(type).toBe(\"object\");\n\nvar type = Type.of([]);\nexpect(type).toBe(\"array\");\n\nvar type = Type.of(1);\nexpect(type).toBe(\"number\");\n\nvar type = Type.of(\"name\");\nexpect(type).toBe(\"string\");\n\nvar type = Type.of(true);\nexpect(type).toBe(\"boolean\");\n\nvar isArray = Type.isArray([]);\nexpect(isArray).toBe(true);\n\nvar isBoolean = Type.isBoolean(true);\nexpect(isBoolean).toBe(true);\n\nvar isFunction = Type.isFunction(function(){});\nexpect(isFunction).toBe(true);\n\nvar isString = Type.isString(\"\");\nexpect(isString).toBe(true);\n\nvar isObject = Type.isObject({});\nexpect(isObject).toBe(true);\n\nvar isObject = Type.isObject(null);\nexpect(isObject).toBe(false);\n\nvar isRegExp = Type.isRegExp(/reg/);\nexpect(isRegExp).toBe(true);\n\nvar isNumber = Type.isNumber(1);\nexpect(isNumber).toBe(true);\n\nvar isNumber = Type.isNumber(\"1.1\");\nexpect(isNumber).toBe(true);\n\nvar isDefined = Type.isDefined(null);\nexpect(isDefined).toBe(false);\n\nvar isDefined = Type.isDefined(undefined);\nexpect(isDefined).toBe(false);\n\nvar isEmpty = Type.isEmpty(\"\");\nexpect(isEmpty).toBe(true);\n\nvar isEmpty = Type.isEmpty([]);\nexpect(isEmpty).toBe(true);\n\nvar isEmpty =  Type.isEmpty({});\nexpect(isEmpty).toBe(true);\n\nvar isEmpty =  Type.isEmpty(null);\nexpect(isEmpty).toBe(true);\n\nvar isString = Type.instanceOf(\"string\", String);\nexpect(isString).toBe(true);\n\n\n\n\n```\n\n\n\n\n\n\n\n### Safe\n\n\nSafe facility provides an API that can helps you safelly working with javascript data types. This methods\nare supposed to work with different value types.\n\n**Methods**\n\n* `Safe.array(value, defaultValue?)`\n<br />\nGets the value in the array representation. __defaultValue__ is returned if defined and if value is not\nan array.\n\n* `Safe.boolean(value, defaultValue?)`\n\n* `Safe.string(value, defaultValue?)`\n\n* `Safe.object(value, defaultValue?)`\n\n* `Safe.number(value, defaultValue?)`\n\n* `Safe.function(value, defaultValue?)`\n\n* `Safe.value(value, defaultValue?)`\n\n* `Safe.regexp(value, defaultValue)`\n\n* `Safe.instanceOf(value, Class)`\n<br />\nGets an instance of the given value if is an instance of the given Class, otherwise it will\ncreate an instance.\n\n* `Safe.length(value)`\n<br />\nGets the length of the value.\n\n* `Safe.coerce(value, expected)`\nGets the value coerced by the expected value type.\n\n**Example** Array\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.array(1);\nexpect(value)\n    .equals([1]);\n\nvar value = Safe.array(1);\nexpect(value)\n    .equals([1]);\n\nvar value = Safe.array([1, 2]);\nexpect(value)\n    .equals([1, 2]);\n\nvar value = Safe.array(null, [ 1, 2 ]);\nexpect(value)\n    .equals([1, 2]);\n\nvar value = Safe.array(\"1\", [1, 2]);\nexpect(value)\n    .equals([\"1\"]);\n\n\n\n```\n\n**Example** Boolean\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.boolean(true);\nexpect(value).toBe(true);\n\nvar value = Safe.boolean(false);\nexpect(value).toBe(false);\n\nvar value = Safe.boolean(1);\nexpect(value).toBe(true);\n\nvar value = Safe.boolean(\"1\");\nexpect(value).toBe(true);\n\nvar value = Safe.boolean(\"0\");\nexpect(value).toBe(false);\n\nvar value = Safe.boolean({});\nexpect(value).toBe(false);\n\nvar value = Safe.boolean({}, true);\nexpect(value).toBe(true);\n\nvar value = Safe.boolean([]);\nexpect(value).toBe(false);\n\nvar value = Safe.boolean(null);\nexpect(value).toBe(false);\n\n\n\n```\n\n**Example** Function\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar fn = Safe.function(function(){});\nexpect(fn())\n    .toBe(undefined);\n\nvar fn = Safe.function(\"\");\nexpect(fn())\n    .toBe(undefined);\n\nvar fn = Safe.function(\"\", function(){ return 1; });\nexpect(fn())\n    .toBe(1);\n\n\n\n```\n\n**Example** Length\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.length([1, 2]);\nexpect(value).toBe(2);\n\nvar value = Safe.length({ one: 1, two: 2});\nexpect(value).toBe(2);\n\nvar value = Safe.length(2);\nexpect(value).toBe(2);\n\nvar value = Safe.length(\"hello\");\nexpect(value).toBe(5);\n\n\n\n```\n\n**Example** Number\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.number(1);\nexpect(value).equals(1);\n\nvar value = Safe.number(\"\");\nexpect(value).equals(0);\n\nvar value = Safe.number(\"1\");\nexpect(value).equals(1);\n\nvar value = Safe.number({});\nexpect(value).equals(0);\n\nvar value = Safe.number(\"\", 1);\nexpect(value).equals(1);\n\n\n\n```\n\n**Example** Object\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.object({ one: 1 });\nexpect(value).equals({ one: 1 });\n\nvar value = Safe.object([]);\nexpect(value).equals({});\n\nvar value = Safe.object([], { one: 1 });\nexpect(value).equals({ one: 1 });\n\n\n\n\n```\n\n**Example** Regex\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.regexp(/regexp/);\nexpect(value)\n    .toEqual(/regexp/);\n\nvar value = Safe.regexp(\"/regexp/\");\nexpect(value)\n    .toEqual(/regexp/);\n\nvar value = Safe.regexp(\"\");\nexpect(value)\n    .toEqual(/^$/);\n\nvar value = Safe.regexp(\"name\");\nexpect(value)\n    .toEqual(/^name$/);\n\nvar value = Safe.regexp({}, /regexp/);\nexpect(value)\n    .toEqual(/regexp/);\n\n\n\n```\n\n**Example** String\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.string(\"\");\nexpect(value).toBe(\"\");\n\nvar value = Safe.string({});\nexpect(value).toBe(\"\");\n\nvar value = Safe.string({}, \"default\");\nexpect(value).toBe(\"default\");\n\n\n\n\n```\n\n**Example** Value\n\n```js\n\n\nvar Safe = Divhide.Safe;\n\nvar value = Safe.value(1);\nexpect(value).toBe(1);\n\nvar value = Safe.value(\"1\");\nexpect(value).toBe(\"1\");\n\nvar value = Safe.value(null);\nexpect(value).toBe(null);\n\nvar value = Safe.value(undefined);\nexpect(value).toBe(null);\n\nvar value = Safe.value(null, 1);\nexpect(value).toBe(1);\n\n\n\n\n```\n\n\n\n### Obj\n\nObject facility provides some utility function to use on Objects.\n\n**Methods**\n\n* `filter(value, filter)`\n<br />\nReturns an array with all the keys that match the __filter__.\n\n\n**Example**\n\n```js\n\n\nvar Obj = Divhide.Obj;\n\nvar results = Obj.filter({ \"one\": 1, \"two\": 2 });\nexpect(results)\n    .toEqual([\"one\", \"two\"]);\n\nvar results = Obj.filter({ \"one\": 1, \"two\": 2 }, \"one\");\nexpect(results)\n    .toEqual([\"one\"]);\n\n\nvar results = Obj.filter({ \"one\": 1, \"two\": 2 }, \"three\");\nexpect(results)\n    .toEqual([]);\n\n\n```\n\n\n### Arr\n\nArray facility provides an API to easily manage array references.\n\n**Methods**\n\n* `index(value, index)`\n<br />\nGets the value of the index.\n\n* `first(value)`\n\n* `last(value)`\n\n* `length(value)`\n\n* `insert(array, value, index?)`\nInserts the given value(s) on the given index of the __array__.\n\n* `remove(array, index, n?)`\nRemoves the given __n__ elements from the __index__ from the __array__.\n\n\n**Example**\n\n```js\n\n\nvar Arr = Divhide.Arr;\n\nvar value = Arr.index([1 ,2, 3], 0);\nexpect(value).toBe(1);\n\nvar value = Arr.index([1 ,2, 3], 10);\nexpect(value).toBeNull();\n\nvar first = Arr.first([1 ,2, 3]);\nexpect(first).toBe(first);\n\nvar last = Arr.last([1 ,2, 3]);\nexpect(last).toBe(3);\n\nvar length = Arr.length([1 ,2, 3]);\nexpect(last).toBe(3);\n\nvar array = [1, 2, 3];\nArr.insert(array, 4);\nexpect(array).toEqual([1, 2, 3, 4]);\n\nvar array = Arr.insert([1 ,2, 3], [4, 5]);\nexpect(array).toEqual([1, 2, 3, 4, 5]);\n\nvar array = Arr.insert([1 ,2, 3], -1, 0);\nexpect(array).toEqual([-1, 1, 2, 3]);\n\nvar array = [1, 2, 3];\nArr.remove(array, 0);\nexpect(array).toEqual([2, 3]);\n\nvar array = [1, 2, 3];\nArr.remove(array, 0, 2);\nexpect(array).toEqual([3]);\n\n\n\n```\n\n\n## Contribute\n\n#### Testing\n\nThe purpose of the project is to provide a library that can be used across every platform that uses javascript. The tests are done using jasmine and using the browser to debug. Every file save on the \"src\" folder will recompile\nthe browserify bundle.\n\n``` bash\n\n## open http://localhost:8585/test/ to run the tests on your browser\ngrunt\n\n```\n\n#### Build\n\nThe build process will run a set of tasks including linting and testing. To contribute please add\ntests to the fix/feature you've worked.\n\nAlso, when building the documention is compiled into the README.md. Each module iniside the \"src\" directory\nshould contain a \".md\" file to document it's behaviour.\n\nThe following command will run the build.\n\n``` bash\n\ngrunt build\n\n```\n\n#### Release\n\n``` bash\n\n## change the package.json, bower.json pre-release version (v1.0.0-1)\ngrunt bump:prerelease\n\n## change the package.json, bower.json minor version (v1.0.1)\ngrunt bump:patch\n\n## Publish current version to npm and bower\ngrunt publish\n\n```\n\n\n\n\n## Authors\n\n**Oscar Brito**\n\n+ [github/aetheon](https://github.com/aetheon)\n+ [twitter/aetheon](http://twitter.com/aetheon)\n\n\n\n\n## License\nCopyright (c) 2015 Oscar Brito <aetheon@gmail.com>, contributors.\nReleased under the  license\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/divhide/node-divhide/issues"
  },
  "homepage": "https://github.com/divhide/node-divhide",
  "_id": "divhide@2.0.1",
  "_from": "divhide@2.0.1"
}
